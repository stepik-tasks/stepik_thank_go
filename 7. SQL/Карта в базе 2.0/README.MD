Доработайте тип `SQLMap`, который вы реализовали в предыдущем задании. Это карта, которая хранит данные в таблице базы. 
Ключи карты — только строки, а значения — произвольного типа.

В предыдущем задании вы сделали три метода — `Get`, `Set` и `Delete`:

```go
// Get возвращает значение для указанного ключа.
// Если такого ключа нет - возвращает ошибку sql.ErrNoRows.
Get(key string) (any, error)

// Set устанавливает значение для указанного ключа.
// Если такой ключ уже есть - затирает старое значение (это не считается ошибкой).
Set(key string, val any) error

// Delete удаляет запись карты с указанным ключом.
// Если такого ключа нет - ничего не делает (это не считается ошибкой).
Delete(key string) error

```

Интерфейс этих методов не меняется. Но требуется поменять внутреннюю реализацию: теперь вместо вызовов `DB.Exec()` 
или `DB.QueryRow()` методы должны использовать подготовленные выражения. Каждый метод должен переиспользовать 
одно выражение, и не создавать новые. Итого должно получиться 3 подготовленных выражения: одно для `Get`, 
одно для `Set`, одно для `Delete`.

Кроме того, добавьте новый метод `Close()`, который закрывает открытые подготовленные выражения:

```go
Close() error
```

Клиент будет вызывать его, когда закончил работать с картой:

```go
// ...
m, err := NewSQLMap(db)
if err != nil {
    panic(err)
}
defer m.Close()
// ...
```

Наконец, добавьте новый метод SetItems(), который устанавливает значения сразу для нескольких ключей:

```go
SetItems(items map[string]any) error
```

Пример использования:

```go
db, err := sql.Open("sqlite3", "map.db")
// ...

m, err := NewSQLMap(db)
if err != nil {
    panic(err)
}
defer m.Close()

m.Set("name", "Alice")

items := map[string]any{
    "name": "Bob",
    "age":  42,
}
m.SetItems(items)

name, err := m.Get("name")
fmt.Printf("name = %v, err = %v\n", name, err)
// name = Bob, err = <nil>

age, err := m.Get("age")
fmt.Printf("age = %v, err = %v\n", age, err)
// age = 42, err = <nil>
```

Внутри SetItems() выполняйте все изменения в одной транзакции.

Чтобы не усложнять задачу, договоримся:

- Клиент сознательный и не вызывает другие методы после того, как вызвал `Close()`. 
Но может вызвать `Close()` дважды, 
и второй вызов при этом не считается ошибкой.
- `SQLMap` используется только из одной горутины.
